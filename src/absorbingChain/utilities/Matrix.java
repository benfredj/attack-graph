package absorbingChain.utilities;// Matrix.javaimport java.awt.*;import java.io.PrintStream;import java.math.BigDecimal;public class Matrix extends java.awt.Panel {		/**	 * 	 */	private static final long serialVersionUID = 1L;	GridBagLayout gbl;	GridBagConstraints gbc;	GridLayout gl;	Double[][] matVals;	Label[][] dl;		public Matrix() {			}		public Matrix(double[][] mv) {		matVals = new Double[mv.length][mv[0].length];		dl = new Label[mv.length][mv[0].length];		for (int r = 0; r < mv.length; r++) {			for (int c = 0; c < mv[0].length; c++) {				matVals[r][c] = new Double(mv[r][c]);				dl[r][c] = new Label(String.valueOf(matVals[r][c].doubleValue()));			}		}			initLayout();	}		public Matrix(Double[][] mv) {		matVals = new Double[mv.length][mv[0].length];		dl = new Label[mv.length][mv[0].length];		for (int r = 0; r < mv.length; r++) {			for (int c = 0; c < mv[0].length; c++) {				matVals[r][c] = mv[r][c];				dl[r][c] = new Label(String.valueOf(matVals[r][c].doubleValue()));			}		}			initLayout();	}		public Matrix(TextField[][] tf) {		matVals = new Double[tf.length][tf[0].length];		dl = new Label[tf.length][tf[0].length];		for (int r = 0; r < tf.length; r++) {			for (int c = 0; c < tf[0].length; c++) {				matVals[r][c] = new Double(tf[r][c].getText());				dl[r][c] = new Label(String.valueOf(matVals[r][c].doubleValue()));			}		}			initLayout();	}		// Return a 2d double array	public double[][] toArray() {		double[][] results = new double[matVals.length][matVals[0].length];;		for (int r = 0; r < matVals.length; r++) {			for (int c = 0; c < matVals[0].length; c++) {				results[r][c] = matVals[r][c].doubleValue();			}		}		return results;	}		// Make layout manager, add components	public void initLayout() {		gl = new GridLayout(matVals.length, matVals[0].length);		setLayout(gl);		for (int r = 0; r < matVals.length; r++) {			for (int c = 0; c < matVals[0].length; c++) {				dl[r][c].setAlignment(Label.CENTER);				add(dl[r][c]);			}		}	}	// Make layout manager, add components	public void display(String name, int round, PrintStream ps) {		ps.println(name+":");		for (int r = 0; r < matVals.length; r++) {			for (int c = 0; c < matVals[0].length; c++) {				if(round>0){					BigDecimal bd = new BigDecimal(Double.toString(matVals[r][c].doubleValue()));				    bd = bd.setScale(round,BigDecimal.ROUND_HALF_UP);				     				    ps.print(bd.doubleValue()+"\t");				}else					ps.print(matVals[r][c]+"\t");			}			ps.println();		}		ps.println();	}		public void display(String name, int round) {		System.out.println(name+":");		for (int r = 0; r < matVals.length; r++) {			for (int c = 0; c < matVals[0].length; c++) {				if(round>0){					BigDecimal bd = new BigDecimal(Double.toString(matVals[r][c].doubleValue()));				    bd = bd.setScale(round,BigDecimal.ROUND_HALF_UP);				     				    System.out.print(bd.doubleValue()+"\t");				}else					System.out.print(matVals[r][c]+"\t");			}			System.out.println();		}		System.out.println();	}		// Make matrix colored	public void setColor(Color myColor) {		for (int r = 0; r < matVals.length; r++) {			for (int c = 0; c < matVals[0].length; c++) {				dl[r][c].setForeground(myColor);			}		}		}		public static Matrix subtract(Matrix a, Matrix b) {		if (a.matVals.length == b.matVals.length && a.matVals[0].length == b.matVals[0].length) {			double[][] results = new double[a.matVals.length][a.matVals[0].length];			for (int r = 0; r < a.matVals.length; r++) {				for (int c = 0; c < a.matVals[0].length; c++) {					results[r][c] = a.matVals[r][c].doubleValue() - b.matVals[r][c].doubleValue();				}			}			return new Matrix(results);		}		return a;					// Again, this is a dumb way to deal with an error in dimension matching	}		public static Matrix add(Matrix a, Matrix b) {		if (a.matVals.length == b.matVals.length && a.matVals[0].length == b.matVals[0].length) {			double[][] results = new double[a.matVals.length][a.matVals[0].length];			for (int r = 0; r < a.matVals.length; r++) {				for (int c = 0; c < a.matVals[0].length; c++) {					results[r][c] = a.matVals[r][c].doubleValue() + b.matVals[r][c].doubleValue();				}			}			return new Matrix(results);		}		return a;					// Again, this is a dumb way to deal with an error in dimension matching	}		public static Matrix multiply(Matrix a, Matrix b) {		if (a.matVals[0].length == b.matVals.length) {			int n = b.matVals.length;			Double[][] results = new Double[a.matVals.length][b.matVals[0].length];			for (int r = 0; r < a.matVals.length; r++) {				for (int c = 0; c < b.matVals[0].length; c++) {					results[r][c] = new Double(0);					for (int i = 0; i < n; i++)						results[r][c] = new Double(results[r][c].doubleValue() +							a.matVals[r][i].doubleValue() * b.matVals[i][c].doubleValue());				}			}		return new Matrix(results);		}	return new Matrix(new Double[0][0]);// means nothing - but we need a return	}		// Return an nXn identity matrix	public static Matrix identity(int n) {		Double[][] results = new Double[n][n];		for (int r = 0; r < n; r++) {			for (int c = 0; c < n; c++) {				if (r == c)					results[r][c] = new Double(1);				else					results[r][c] = new Double(0);			}		}			return new Matrix(results);	}		// Make matrix filled with ones	public static Matrix con(int rows, int cols) {		Double[][] results = new Double[rows][cols];		for (int r = 0; r < rows; r++) {			for (int c = 0; c < cols; c++) {				results[r][c] = new Double(1);			}		}			return new Matrix(results);	}		// Matrix of zeros	public static Matrix zer(int rows, int cols) {		Double[][] results = new Double[rows][cols];		for (int r = 0; r < rows; r++) {			for (int c = 0; c < cols; c++) {				results[r][c] = new Double(0);			}		}			return new Matrix(results);	}		// Use solve to find the inverse of a square matrix	public Matrix inverse() {		if (matVals.length	== matVals[0].length) {			int n = matVals.length;			return solve(this, identity(n));			}		return this;					// Junk for non-square case	}		// Solve a square matrix a for b, which is the identity matrix when this is used to find the inverse of a	public static Matrix solve(Matrix a, Matrix b) {		// Make sure a is square and has the same number of rows as b		if (a.matVals.length == a.matVals[0].length && a.matVals.length == b.matVals.length) {			int n = a.matVals.length;			// Size of a			int bc = b.matVals[0].length;		// Columns in b -> number of seperate systems of equations			double[][] af = new double[n][n];		// Get matrices as simple double 2d arrays			double[][] bf = new double[n][bc];			for (int r = 0; r < n; r++) {				for (int c = 0; c < n; c++) {					af[r][c] = a.matVals[r][c].doubleValue();				}			}			for (int r = 0; r < n; r++) {				for (int c = 0; c < bc; c++) {					bf[r][c] = b.matVals[r][c].doubleValue();				}			}						int max;			// row num of biggest element in the column			double t;				// temp for switch						for (int i = 0; i < n; i++) {				max = i;				for (int j = i + 1; j < n; j++) {			// Figure out which rows to switch					if (Math.abs((double) af[j][i]) > Math.abs((double) af[max][i]))						max = j;					}				for (int k = i; k < n; k++) {			// Switch each element in the two rows in a					t = af[i][k];					af[i][k] = af[max][k];					af[max][k] = t;					}				for (int k = 0; k < bc; k++) {		// and in b					t = bf[i][k];					bf[i][k] = bf[max][k];					bf[max][k] = t;					}				for (int j = i + 1; j < n; j++) {			// Triangulate					for (int k = bc - 1; k >= 0; k--) {						bf[j][k] -= bf[i][k] * af[j][i] / af[i][i];					}					for (int k = n - 1; k >= i; k--) {						af[j][k] -= af[i][k] * af[j][i] / af[i][i];					}					}				}						double total;			for (int i = 0; i < bc; i++) {				// For each system (column in b)				for (int j = n - 1; j >= 0; j--) {			// Start at bottom (1 variable) and go to top					total = 0;									// Total  from known variables					for (int k = j + 1; k < n; k++) {			// Add up known variables						total += af[j][k] * bf[k][i];					}					bf[j][i] = (bf[j][i] - total) / af[j][j];		// Solve next unknown				}			}			return new Matrix(bf);		}		return b;							// JUNK - dimensions are wrong	}		public void round(int accuracy) {		for (int r = 0; r < matVals.length; r++) {			for (int c = 0; c < matVals[0].length; c++) {				BigDecimal bd = new BigDecimal(Double.toString(matVals[r][c].doubleValue()));			    bd = bd.setScale(accuracy,BigDecimal.ROUND_HALF_UP);			     				matVals[r][c] = new Double(bd.doubleValue());								dl[r][c].setText(String.valueOf(matVals[r][c].doubleValue()));			}		}	}	}