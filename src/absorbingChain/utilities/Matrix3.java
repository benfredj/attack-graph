package absorbingChain.utilities;// Matrix.javaimport java.math.BigDecimal;public class Matrix3 {		/**	 * 	 */	private static final long serialVersionUID = 1L;	Fraction[][] matVals;		public Matrix3() {			}		public Matrix3(int[][] mv) {		matVals = new Fraction[mv.length][mv[0].length];		for (int r = 0; r < mv.length; r++) {			for (int c = 0; c < mv[0].length; c++) {				matVals[r][c] = new Fraction(mv[r][c]);			}		}		}		public Matrix3(Integer[][] mv) {		matVals = new Fraction[mv.length][mv[0].length];		for (int r = 0; r < mv.length; r++) {			for (int c = 0; c < mv[0].length; c++) {				matVals[r][c] = new Fraction(mv[r][c]);			}		}		}	public Matrix3(Fraction[][] mv) {		matVals = new Fraction[mv.length][mv[0].length];		for (int r = 0; r < mv.length; r++) {			for (int c = 0; c < mv[0].length; c++) {				if(mv[r][c]==null)				matVals[r][c] = new Fraction(0);				else					matVals[r][c] = mv[r][c];			}		}		}		// Return a 2d double array	public double[][] toArray() {		double[][] results = new double[matVals.length][matVals[0].length];;		for (int r = 0; r < matVals.length; r++) {			for (int c = 0; c < matVals[0].length; c++) {				results[r][c] = matVals[r][c].doubleValue();			}		}		return results;	}	// Return a 2d double array	public Fraction[][] toFractionArray() {		Fraction[][] results = new Fraction[matVals.length][matVals[0].length];;		for (int r = 0; r < matVals.length; r++) {			for (int c = 0; c < matVals[0].length; c++) {				results[r][c] = matVals[r][c];			}		}		return results;	}		// Make layout manager, add components	public void display(String name) {		System.out.println(name+":");		for (int r = 0; r < matVals.length; r++) {			for (int c = 0; c < matVals[0].length; c++) {				System.out.print(matVals[r][c]+"\t");			}			System.out.println();		}		System.out.println();	}			public static Matrix3 subtract(Matrix3 a, Matrix3 b) {		if (a.matVals.length == b.matVals.length && a.matVals[0].length == b.matVals[0].length) {			Fraction[][] results = new Fraction[a.matVals.length][a.matVals[0].length];			for (int r = 0; r < a.matVals.length; r++) {				for (int c = 0; c < a.matVals[0].length; c++) {					results[r][c] = a.matVals[r][c].subtract(b.matVals[r][c]);				}			}			return new Matrix3(results);		}		return a;					// Again, this is a dumb way to deal with an error in dimension matching	}		public static Matrix3 add(Matrix3 a, Matrix3 b) {		if (a.matVals.length == b.matVals.length && a.matVals[0].length == b.matVals[0].length) {			Fraction[][] results = new Fraction[a.matVals.length][a.matVals[0].length];			for (int r = 0; r < a.matVals.length; r++) {				for (int c = 0; c < a.matVals[0].length; c++) {					results[r][c] = a.matVals[r][c].add(b.matVals[r][c]);				}			}			return new Matrix3(results);		}		return a;					// Again, this is a dumb way to deal with an error in dimension matching	}		public static Matrix3 multiply(Matrix3 a, Matrix3 b) {		if (a.matVals[0].length == b.matVals.length) {			int n = b.matVals.length;			Fraction[][] results = new Fraction[a.matVals.length][b.matVals[0].length];			for (int r = 0; r < a.matVals.length; r++) {				for (int c = 0; c < b.matVals[0].length; c++) {					results[r][c] = new Fraction(0);					for (int i = 0; i < n; i++)						results[r][c] = results[r][c].add(a.matVals[r][i].multiplyBy(b.matVals[i][c]));				}			}		return new Matrix3(results);		}	return new Matrix3(new Integer[0][0]);// means nothing - but we need a return	}		// Return an nXn identity matrix	public static Matrix3 identity(int n) {		Fraction[][] results = new Fraction[n][n];		for (int r = 0; r < n; r++) {			for (int c = 0; c < n; c++) {				if (r == c)					results[r][c] = new Fraction(1);				else					results[r][c] = new Fraction(0);			}		}			return new Matrix3(results);	}		// Make matrix filled with ones	public static Matrix3 con(int rows, int cols) {		Fraction[][] results = new Fraction[rows][cols];		for (int r = 0; r < rows; r++) {			for (int c = 0; c < cols; c++) {				results[r][c] = new Fraction(1);			}		}			return new Matrix3(results);	}		// Matrix of zeros	public static Matrix3 zer(int rows, int cols) {		Fraction[][] results = new Fraction[rows][cols];		for (int r = 0; r < rows; r++) {			for (int c = 0; c < cols; c++) {				results[r][c] = new Fraction(0);			}		}			return new Matrix3(results);	}		// Use solve to find the inverse of a square matrix	public Matrix3 inverse() {		if (matVals.length	== matVals[0].length) {			int n = matVals.length;			return solve(this, identity(n));			}		return this;					// Junk for non-square case	}		// Solve a square matrix a for b, which is the identity matrix when this is used to find the inverse of a	public static Matrix3 solve(Matrix3 a, Matrix3 b) {		// Make sure a is square and has the same number of rows as b		if (a.matVals.length == a.matVals[0].length && a.matVals.length == b.matVals.length) {			int n = a.matVals.length;			// Size of a			int bc = b.matVals[0].length;		// Columns in b -> number of seperate systems of equations			Fraction[][] af = new Fraction[n][n];		// Get matrices as simple double 2d arrays			Fraction[][] bf = new Fraction[n][bc];			for (int r = 0; r < n; r++) {				for (int c = 0; c < n; c++) {					af[r][c] = a.matVals[r][c];				}			}			for (int r = 0; r < n; r++) {				for (int c = 0; c < bc; c++) {					bf[r][c] = b.matVals[r][c];				}			}						int max;			// row num of biggest element in the column			Fraction t;				// temp for switch						for (int i = 0; i < n; i++) {				max = i;				for (int j = i + 1; j < n; j++) {			// Figure out which rows to switch					if (Math.abs(af[j][i].doubleValue()) > Math.abs(af[max][i].doubleValue()))						max = j;					}				for (int k = i; k < n; k++) {			// Switch each element in the two rows in a					t = af[i][k];					af[i][k] = af[max][k];					af[max][k] = t;					}				for (int k = 0; k < bc; k++) {		// and in b					t = bf[i][k];					bf[i][k] = bf[max][k];					bf[max][k] = t;					}				for (int j = i + 1; j < n; j++) {			// Triangulate					for (int k = bc - 1; k >= 0; k--) {						bf[j][k] = bf[j][k].subtract(bf[i][k].multiplyBy(af[j][i]).divideBy(af[i][i]));					}					for (int k = n - 1; k >= i; k--) {						af[j][k] = af[j][k].subtract(af[i][k].multiplyBy(af[j][i]).divideBy(af[i][i]));					}				}				}						Fraction total;			for (int i = 0; i < bc; i++) {				// For each system (column in b)				for (int j = n - 1; j >= 0; j--) {			// Start at bottom (1 variable) and go to top					total = new Fraction(0);									// Total  from known variables					for (int k = j + 1; k < n; k++) {			// Add up known variables						total = total.add(af[j][k].multiplyBy(bf[k][i]));					}					bf[j][i] = (bf[j][i].subtract(total)).divideBy(af[j][j]);		// Solve next unknown				}			}			return new Matrix3(bf);		}		return b;							// JUNK - dimensions are wrong	}	}