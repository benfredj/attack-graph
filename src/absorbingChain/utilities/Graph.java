package absorbingChain.utilities;import java.awt.*;// do better adjustment when axis are near borders// account for x labels getting cut off - either adjust, or just don't print that label// better organization???// Scientific notation?public abstract class Graph extends java.awt.Canvas {		Float xCoords[];						// x coordinates of data points that are passed in	Float yCoords[];						// y coordinates		int w, h;								// width and height of this component		float scaleX;							// Number of pixels per data unit x	float scaleY;							// ... and for y		Point pixels[];					// Points that contain rescaled data points - subclasses should use this		Point tickStarts[];			// One end of each tick mark	Point tickEnds[];				// The other end of the corresponding tick mark		String xLabels[];				// x and y labels	String yLabels[];		Point xLabelPoints[];			// Points at which to start drawing text of labels	Point yLabelPoints[];		float minX, maxX, minY, maxY;		// Range variables for graph	int length;						// Number of data points		int inset = 15;						// Inset around edge of component		// Set up a generic graph object with boring initial values ---- messed up, should have two points????	public Graph() {		super();		minX = 0;		maxX = 0;		minY = 0;		maxY = 0;		length = 0;		xCoords = new Float[1];		yCoords = new Float[1];		xCoords[0] = new Float(0);		yCoords[0] = new Float(0);	}		// Set up a generic graph object, given two arrays. Copy the arrays, find the range, and call scale(),	// to calculate pixel coordinates.	// Exception for different lengths???	// At the moment, Float[] x and Float[] are assumed to be the same length	public Graph(Float[] x, Float[] y) {		super();								// Set up as we would for a canvas		minX = Float.POSITIVE_INFINITY;		// Initialize bounds		maxX = Float.NEGATIVE_INFINITY;		minY = Float.POSITIVE_INFINITY;						maxY = Float.NEGATIVE_INFINITY;		length = x.length;						// get the number of data points		xCoords = new Float[length];			// Set up arrays for x and y coordinates of data points		yCoords = new Float[length];		for(int i = 0; i < length; i++)		// Copy arrays, and store range variables		{			xCoords[i] = x[i];			yCoords[i] = y[i];			if (xCoords[i].floatValue() > maxX)				maxX = xCoords[i].floatValue();			if (xCoords[i].floatValue() < minX)				minX = xCoords[i].floatValue();			if (yCoords[i].floatValue() > maxY)				maxY = yCoords[i].floatValue();			if (yCoords[i].floatValue() < minY)				minY = yCoords[i].floatValue();		}	}		public int adjX(Float oldX) {		return adjX(oldX.floatValue());	}		public int adjY(Float oldY) {		return adjY(oldY.floatValue());	}		public int adjX(float oldX) {		return (int) ((float) (oldX - minX) * scaleX) + inset;	}		public int adjY(float oldY) {		return (int) ((float) (maxY - oldY) * scaleY) + inset;	}		// Determines size of this object, and scales the coordinates accordingly.	public void setPoints() {		Dimension d = size();  //getSize() in 1.1.1		w = d.width - 2 * inset;						h = d.height - 2 * inset;					pixels = new Point[length];			// Initialize array for actual points to be graphed				if (Math.abs(minX) < .1 * (maxX - minX))			// Do a stupid adjustment if we are near axis - I should fix this !!!!!!!!!!!!			minX = (float) -.1 * (maxX - minX);		if (Math.abs(minY) < .1 * (maxY - minY))			minY = (float) -.1 * (maxY - minY);				if (maxX - minX != 0)			scaleX = (float) w / (maxX - minX);	// Total width / range													// = number of pixels for each point		if (maxY - minY != 0)						// Simalarly for y scale			scaleY = (float) h / (maxY - minY);					int x, y;									// current x and y coordinates		for (int i = 0; i < length; i++) {			// Calculate what the coordinates of each data point should be, then add a Point object to the array			x = adjX(xCoords[i]);			y = adjY(yCoords[i]);			pixels[i] = new Point(x, y);		}	}		// Choose increment for tick marks and labels, and determine their coordinates	public void setTicks(boolean onAxis, FontMetrics fm) {		int labelSpace = 35;		// Try to space labels approximately this many pixels apart		int numX, numY;			// Number of x and y ticks		float xSpace, ySpace;		// Spacing between x and y ticks		float x, y;				// Temporary storage for x and y coordinates		int expX, expY;			// power, when x and y Space are adjusted as scientific notation		float firstX, firstY;		// x-coordinate of first x tick, y- coord of first y				// Determine number of ticks on each axis, and spacing between ticks		numX = (int) Math.floor((float) w / (float) labelSpace) + 1;	// No. of ticks, with labelSpace greatest space in between		numY = (int) Math.floor((float) h / (float) labelSpace) + 1;				xSpace = (float) (maxX - minX) / (float) (numX - 1);			// Exact value of interval, with that many ticks		ySpace = (float) (maxY - minY) / (float) (numY - 1);				expX = (int) Math.floor((float) (Math.log(xSpace) / Math.log(10)));	// Approximate scale of interval. e.g. 34 -> 1, .049 -> -2		expY = (int) Math.floor((float) (Math.log(ySpace) / Math.log(10)));				xSpace = xSpace / (float) Math.pow((double) 10, (double) expX);// Re-adjust, so that we are between 1 incl. and 10 excl.		ySpace = ySpace / (float) Math.pow((double) 10, (double) expY);				if (xSpace == 1)													// Round off to 1, 2, 5, or 10			xSpace = (float) 1;											// so that the interval will be .1, 1, 10, .2, 2, 20,		else if (xSpace <= 2)												// .5, 5, 50, etc.... i.e. 1eX, 2eX, or 5eX - sort of nice, even numbers			xSpace = (float) 2;		else if (xSpace <= 5)			xSpace = (float) 5;		else			xSpace = 10;					if (ySpace == 1)			ySpace = (float) 1;		else if (ySpace <= 2)			ySpace = (float) 2;		else if (ySpace <= 5)			ySpace = (float) 5;		else			ySpace = 10;					xSpace = xSpace * (float) Math.pow((double) 10, (double) expX);			// multiply to get back original scale		ySpace = ySpace * (float) Math.pow((double) 10, (double) expY);				numX = (int) Math.floor((float) (maxX - minX) / xSpace) + 1;	// recalculate number of ticks, because we may be way off from		numY = (int) Math.floor((float) (maxY - minY) / ySpace) + 1;	// our original estimate				// Create arrays to store coordinates and label values		tickStarts = new Point[numX + numY];		tickEnds = new Point[numX + numY];		xLabels = new String[numX];		xLabelPoints = new Point[numX];		yLabels = new String[numY];		yLabelPoints = new Point[numY];				// Find starting points		firstX = (int) Math.ceil((float) minX / (float) xSpace) * xSpace;		firstY = (int) Math.ceil((float) minY / (float) ySpace) * ySpace;				if(minX < 0) {					// If the x axis is visible			// Set up each x tick			for (int i = 0; i < numX; i++) {				x = firstX + i * xSpace;				tickStarts[i] = new Point(adjX(x),					adjY(0) - 1);				tickEnds[i] = new Point(adjX(x),					adjY(0) + 1);				if (x == 0 && onAxis)					xLabels[i] = new String("");						// Don't label 0 - it's obvious, and gets in the way of the axis				else					xLabels[i] = new String(String.valueOf(x));				xLabelPoints[i] = new Point(adjX(x) - fm.stringWidth(xLabels[i]) / 2,					adjY(0) + fm.getHeight() - fm.getLeading() + 2);			}		}		else {							// if x axis is not visible, we need ticks to show up						// Set up each x tick			for (int i = 0; i < numX; i++) {					x = firstX + i * xSpace;				tickStarts[i] = new Point(adjX(x), h + inset - 1);				tickEnds[i] = new Point(adjX(x), h + inset + 1);				if (x != 0)					xLabels[i] = new String(String.valueOf(x));				else					xLabels[i] = new String(" ");						// Don't label 0 - it's obvious, and gets in the way of the axis				xLabelPoints[i] = new Point(adjX(x) - fm.stringWidth(xLabels[i]) / 2,					h + inset + fm.getHeight() - fm.getLeading() + 2);			}		}					if (onAxis && minY < 0) {		// If the the ticks should be on the y axis, and we can see it			// Set up each y tick			for (int i = 0; i < numY; i++) {						y = firstY + i * ySpace;				tickStarts[numX + i] = new Point(adjX(0) - 1, adjY(y));				tickEnds[numX + i] = new Point(adjX(0) + 1, adjY(y));				if (y != 0)					yLabels[i] = new String(String.valueOf(y));				else					yLabels[i] = new String(" ");		// Don't label 0 - it's obvious, and gets in the way of the axis				yLabelPoints[i] = new Point(adjX(0) - fm.stringWidth(yLabels[i]) - 2,					adjY(y) + (fm.getHeight() - fm.getLeading()) / 2);			}		}		else {						// if ticks should not be on y axis, or we can't see it			// Set up each y tick			for (int i = 0; i < numY; i++) {					int lblWidth = Math.max(Math.max(fm.stringWidth(String.valueOf(firstY)), // longest should be highest or lowest, or next highest or lowest,						fm.stringWidth(String.valueOf(firstY + (numY - 1) * ySpace))),	// if .5 is the interval					Math.max(fm.stringWidth(String.valueOf(firstY + 1 * ySpace)), 						fm.stringWidth(String.valueOf(firstY + (numY - 2) * ySpace)))) + 2;				y = firstY + i * ySpace;				tickStarts[numX + i] = new Point(lblWidth + inset - 1, adjY(y));				tickEnds[numX + i] = new Point(lblWidth + inset + 1, adjY(y));				if (y != 0)					yLabels[i] = new String(String.valueOf(y));				else					yLabels[i] = new String("");	// Don't label 0 - it's obvious, and gets in the way of the axis				yLabelPoints[i] = new Point(inset + lblWidth - fm.stringWidth(yLabels[i]) - 2,					adjY(y) + (fm.getHeight() - fm.getLeading()) / 2);			}		}	}		// Paint method, which should be redefined by subclasses to actually show the data points	public void paint(Graphics g) {		FontMetrics fm;				if (length > 0) { 					// Make sure we have at least one point			fm = g.getFontMetrics();			setPoints();				// When we are ready to paint, the dimensions of the component have been			setTicks(true, fm);			// set, so we can calculate coordinates of all the points			g.setColor(new Color(0, 0, 0));			drawXAxis(g);			drawYAxis(g);			g.setColor(new Color(150, 0, 0));			// Make ticks red			drawTicks(g);			g.setColor(new Color(0, 0, 100));			// Make labels blue			labelTicks(g);			g.setColor(new Color(0, 0, 0));		}	}		public void drawXAxis(Graphics g) {		g.drawLine(inset, adjY(0), w + inset, adjY(0));	}		public void drawYAxis(Graphics g) {		g.drawLine(adjX(0), inset, adjX(0), h + inset);	}		public void drawTicks(Graphics g) {		for (int i = 0; i < tickStarts.length; i++) {			g.drawLine(tickStarts[i].x, tickStarts[i].y, tickEnds[i].x,				tickEnds[i].y);			}	}		public void labelTicks(Graphics g) {		for (int i = 0; i < xLabels.length; i++) {			g.drawString(xLabels[i], xLabelPoints[i].x, xLabelPoints[i].y);			}		for (int i = 0; i < yLabels.length; i++) {			g.drawString(yLabels[i], yLabelPoints[i].x, yLabelPoints[i].y);			}	}	}