package absorbingChain.utilities;import java.awt.*;public class OESpikeGraph extends Graph {	Float yCoordsO[];				// observed y coords - yCoords[] will be expected	int yPixelsO[];				// pixel points for y coord of observed values	int insetB;	public OESpikeGraph() {		super();		yCoordsO = new Float[1];		yCoordsO[0] = new Float(0);		insetB = 40;	}		public OESpikeGraph(Float[] x, Float[] yo, Float[] ye) {		super(x, ye);				yCoordsO = new Float[length];		for(int i = 0; i < length; i++)		// Copy arrays, and store range variables		{			yCoordsO[i] = yo[i];			if (yCoordsO[i].floatValue() > maxY)				maxY = yCoordsO[i].floatValue();			if (yCoordsO[i].floatValue() < minY)				minY = yCoordsO[i].floatValue();		}		insetB = 40;	}		// Determines size of this object, and scales the coordinates accordingly.	public void setPoints() {		Dimension d = size();  //getSize() in 1.1.1		w = d.width - 2 * inset;						h = d.height - 2 * inset - insetB;					pixels = new Point[length];			// Initialize array for actual points to be graphed				if (Math.abs(minX) < .1 * (maxX - minX))			// Do a stupid adjustment if we are near axis - I should fix this !!!!!!!!!!!!			minX = (float) -.1 * (maxX - minX);		if (Math.abs(minY) < .1 * (maxY - minY))			minY = (float) -.1 * (maxY - minY);				if (maxX - minX != 0)			scaleX = (float) w / (maxX - minX);	// Total width / range													// = number of pixels for each point		if (maxY - minY != 0)						// Simalarly for y scale			scaleY = (float) h / (maxY - minY);					int x, y;									// current x and y coordinates		for (int i = 0; i < length; i++) {			// Calculate what the coordinates of each data point should be, then add a Point object to the array			x = adjX(xCoords[i]);			y = adjY(yCoords[i]);			pixels[i] = new Point(x, y);		}				yPixelsO = new int[length];			// Initialize array for actual points to be graphed				for (int i = 0; i < length; i++) {			// Calculate what the coordinates of each data point should be, then add int to the array			yPixelsO[i] = adjY(yCoordsO[i]);		}	}		public void paint(Graphics g) {		Font f;		String fName;		FontMetrics fm;			if (length > 0) { 					// Make sure we have at least one point			f = g.getFont();			fName = f.getName();			f = new Font(fName, Font.PLAIN, 9);			g.setFont(f);			fm = g.getFontMetrics();					setPoints();				// When we are ready to paint, the dimensions of the component have been			setTicks(false, fm);			// set, so we can calculate coordinates of all the points			for (int i = 0; i < length; i++) {		// For each point				g.setColor(new Color(0, 0, 0));				g.drawLine(pixels[i].x, adjY(0), pixels[i].x, 	// Make spike to highest value					(int) Math.min((double) pixels[i].y, (double) yPixelsO[i]));				g.setColor(new Color(0, 0, 100));				g.drawRect(pixels[i].x - 2, yPixelsO[i] - 2, 5, 5);				g.setColor(new Color(150, 0, 0));				g.drawOval(pixels[i].x - 2, pixels[i].y - 2, 5, 5);			}						g.setColor(new Color(0, 0, 100));					// Sample points for observed and expected			g.drawRect(inset, h + inset + 10, 5, 5);			g.drawString("Observed", inset + 10, h + inset + 20);			g.setColor(new Color(150, 0, 0));			g.drawOval(inset, h + inset + 30, 5, 5);			g.drawString("Expected", inset + 10, h + inset + 40);						g.setColor(new Color(0, 0, 0));			drawXAxis(g);			g.setColor(new Color(150, 0, 0));			// Make ticks red			drawTicks(g);			g.setColor(new Color(0, 0, 100));			// Make labels blue			labelTicks(g);			g.setColor(new Color(0, 0, 0));		}	}	}